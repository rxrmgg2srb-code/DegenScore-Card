// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Optimización para alta concurrencia
  // Configurar en DATABASE_URL: ?connection_limit=20&pool_timeout=20
}

model DegenCard {
  id              String    @id @default(cuid())
  walletAddress   String    @unique
  
  // Métricas básicas
  degenScore      Int
  totalTrades     Int
  totalVolume     Float
  profitLoss      Float
  winRate         Float
  bestTrade       Float
  worstTrade      Float
  avgTradeSize    Float
  totalFees       Float
  tradingDays     Int
  level           Int
  xp              Int
  
  // Métricas avanzadas
  rugsSurvived    Int       @default(0)
  rugsCaught      Int       @default(0)
  totalRugValue   Float     @default(0)
  moonshots       Int       @default(0)
  avgHoldTime     Float     @default(0)
  quickFlips      Int       @default(0)
  diamondHands    Int       @default(0)
  realizedPnL     Float     @default(0)
  unrealizedPnL   Float     @default(0)
  firstTradeDate  DateTime?
  longestWinStreak Int      @default(0)
  longestLossStreak Int     @default(0)
  volatilityScore Float     @default(0)
  
  // Datos sociales/perfil
  displayName     String?
  twitter         String?
  telegram        String?
  profileImage    String?
  
  // Estado
  isMinted        Boolean   @default(false)
  isPaid          Boolean   @default(false)
  mintedAt        DateTime  @default(now())
  lastSeen        DateTime  @default(now())
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Sistema de Likes
  likes           Int       @default(0)
  
  // Relaciones
  badges          Badge[]
  
  // Índices simples para consultas individuales
  @@index([degenScore])
  @@index([totalVolume])
  @@index([winRate])
  @@index([isPaid])
  @@index([likes])
  @@index([mintedAt])
  @@index([createdAt])

  // Índices compuestos para leaderboard (ordenamiento)
  @@index([degenScore(sort: Desc), mintedAt(sort: Desc)])
  @@index([totalVolume(sort: Desc), mintedAt(sort: Desc)])
  @@index([winRate(sort: Desc), mintedAt(sort: Desc)])
  @@index([likes(sort: Desc), mintedAt(sort: Desc)])
}

model Badge {
  id          String     @id @default(cuid())
  name        String
  description String
  icon        String
  rarity      String
  cardId      String
  card        DegenCard  @relation(fields: [cardId], references: [id], onDelete: Cascade)
  
  @@index([cardId])
}

model Payment {
  id            String   @id @default(cuid())
  walletAddress String
  amount        Float
  signature     String   @unique
  status        String
  createdAt     DateTime @default(now())
  
  @@index([walletAddress])
  @@index([signature])
}

model GlobalStats {
  id            String   @id @default("singleton")
  totalCards    Int      @default(0)
  totalMinted   Int      @default(0)
  totalVolume   Float    @default(0)
  avgDegenScore Float    @default(0)
  topScore      Int      @default(0)
  updatedAt     DateTime @updatedAt
}

model HotTrade {
  id              String   @id @default(cuid())
  walletAddress   String   // Top wallet que hizo el trade
  displayName     String?  // Nombre del degen
  tokenMint       String
  tokenSymbol     String?
  type            String   // "buy" | "sell"
  solAmount       Float    
  timestamp       DateTime
  degenScore      Int      // Score del wallet en ese momento
  
  createdAt       DateTime @default(now())
  
  @@index([timestamp])
  @@index([walletAddress])
  @@index([createdAt])
}

model Subscription {
  id              String   @id @default(cuid())
  walletAddress   String   @unique
  tier            String   @default("FREE") // "FREE" | "BASIC" | "PRO"
  expiresAt       DateTime?
  paymentSignature String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([walletAddress])
  @@index([tier])
}

model PromoCode {
  id              String   @id @default(cuid())
  code            String   @unique
  description     String?
  maxUses         Int      @default(0) // 0 = unlimited
  usedCount       Int      @default(0)
  isActive        Boolean  @default(true)
  expiresAt       DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relación con usos
  redemptions     PromoRedemption[]

  @@index([code])
  @@index([isActive])
}

model PromoRedemption {
  id              String   @id @default(cuid())
  promoCodeId     String
  promoCode       PromoCode @relation(fields: [promoCodeId], references: [id], onDelete: Cascade)
  walletAddress   String

  createdAt       DateTime @default(now())

  @@index([promoCodeId])
  @@index([walletAddress])
  @@unique([promoCodeId, walletAddress]) // Un usuario solo puede usar un código una vez
}

model WeeklyChallenge {
  id              String   @id @default(cuid())
  week            Int      @unique // Week number of the year
  year            Int
  title           String
  description     String
  metric          String   // "likes", "profit", "winRate", "volume", "bestTrade"
  prizeSOL        Float    @default(3.0)
  startDate       DateTime
  endDate         DateTime
  winnerAddress   String?
  winnerScore     Float?
  isActive        Boolean  @default(true)

  createdAt       DateTime @default(now())

  @@index([week, year])
  @@index([isActive])
  @@index([endDate])
}

model Referral {
  id                String   @id @default(cuid())
  referrerAddress   String   // Quien refiere
  referredAddress   String   // Quien fue referido
  hasPaid           Boolean  @default(false) // Si el referido pagó
  paidAt            DateTime? // Cuándo pagó
  rewardPaid        Boolean  @default(false) // Si se pagó reward (para futuro)
  rewardAmount      Float?   // Cuánto se pagó (para futuro)

  createdAt         DateTime @default(now())

  @@index([referrerAddress])
  @@index([referredAddress])
  @@index([hasPaid])
  @@unique([referrerAddress, referredAddress]) // No duplicar referidos
}