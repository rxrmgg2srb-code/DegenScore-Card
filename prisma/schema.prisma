// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Optimización para alta concurrencia
  // Configurar en DATABASE_URL: ?connection_limit=20&pool_timeout=20
}

model DegenCard {
  id              String    @id @default(cuid())
  walletAddress   String    @unique
  
  // Métricas básicas
  degenScore      Int
  totalTrades     Int
  totalVolume     Float
  profitLoss      Float
  winRate         Float
  bestTrade       Float
  worstTrade      Float
  avgTradeSize    Float
  totalFees       Float
  tradingDays     Int
  level           Int
  xp              Int
  
  // Métricas avanzadas
  rugsSurvived    Int       @default(0)
  rugsCaught      Int       @default(0)
  totalRugValue   Float     @default(0)
  moonshots       Int       @default(0)
  avgHoldTime     Float     @default(0)
  quickFlips      Int       @default(0)
  diamondHands    Int       @default(0)
  realizedPnL     Float     @default(0)
  unrealizedPnL   Float     @default(0)
  firstTradeDate  DateTime?
  longestWinStreak Int      @default(0)
  longestLossStreak Int     @default(0)
  volatilityScore Float     @default(0)
  
  // Datos sociales/perfil
  displayName     String?
  twitter         String?
  telegram        String?
  profileImage    String?

  // Daily Streaks & Engagement
  lastCheckIn     DateTime?
  streakDays      Int       @default(0)
  totalXP         Int       @default(0)
  longestStreak   Int       @default(0)

  // Estado
  isMinted        Boolean   @default(false)
  isPaid          Boolean   @default(false)
  mintedAt        DateTime  @default(now())
  lastSeen        DateTime  @default(now())
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Sistema de Likes
  likes           Int       @default(0)
  
  // Relaciones
  badges          Badge[]
  
  // Índices simples para consultas individuales
  @@index([degenScore])
  @@index([totalVolume])
  @@index([winRate])
  @@index([isPaid])
  @@index([likes])
  @@index([mintedAt])
  @@index([createdAt])

  // Índices compuestos para leaderboard (ordenamiento)
  @@index([degenScore(sort: Desc), mintedAt(sort: Desc)])
  @@index([totalVolume(sort: Desc), mintedAt(sort: Desc)])
  @@index([winRate(sort: Desc), mintedAt(sort: Desc)])
  @@index([likes(sort: Desc), mintedAt(sort: Desc)])

  // PERFORMANCE: Índices adicionales para queries comunes
  @@index([isPaid, degenScore(sort: Desc), createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@index([lastSeen(sort: Desc)])
}

model Badge {
  id          String     @id @default(cuid())
  name        String
  description String
  icon        String
  rarity      String
  cardId      String
  card        DegenCard  @relation(fields: [cardId], references: [id], onDelete: Cascade)
  
  @@index([cardId])
}

model Payment {
  id            String   @id @default(cuid())
  walletAddress String
  amount        Float
  signature     String   @unique
  status        String
  createdAt     DateTime @default(now())
  
  @@index([walletAddress])
  @@index([signature])
}

model GlobalStats {
  id            String   @id @default("singleton")
  totalCards    Int      @default(0)
  totalMinted   Int      @default(0)
  totalVolume   Float    @default(0)
  avgDegenScore Float    @default(0)
  topScore      Int      @default(0)
  updatedAt     DateTime @updatedAt
}

model HotTrade {
  id              String   @id @default(cuid())
  walletAddress   String   // Top wallet que hizo el trade
  displayName     String?  // Nombre del degen
  tokenMint       String
  tokenSymbol     String?
  type            String   // "buy" | "sell"
  solAmount       Float    
  timestamp       DateTime
  degenScore      Int      // Score del wallet en ese momento
  
  createdAt       DateTime @default(now())

  @@index([timestamp])
  @@index([walletAddress])
  @@index([createdAt])

  // PERFORMANCE: Índice compuesto para consultas por wallet y tiempo
  @@index([walletAddress, timestamp(sort: Desc)])
}

model Subscription {
  id              String   @id @default(cuid())
  walletAddress   String   @unique
  tier            String   @default("FREE") // "FREE" | "BASIC" | "PRO"
  expiresAt       DateTime?
  paymentSignature String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([walletAddress])
  @@index([tier])
}

model PromoCode {
  id              String   @id @default(cuid())
  code            String   @unique
  description     String?
  maxUses         Int      @default(0) // 0 = unlimited
  usedCount       Int      @default(0)
  isActive        Boolean  @default(true)
  expiresAt       DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relación con usos
  redemptions     PromoRedemption[]

  @@index([code])
  @@index([isActive])
}

model PromoRedemption {
  id              String   @id @default(cuid())
  promoCodeId     String
  promoCode       PromoCode @relation(fields: [promoCodeId], references: [id], onDelete: Cascade)
  walletAddress   String

  createdAt       DateTime @default(now())

  @@index([promoCodeId])
  @@index([walletAddress])
  @@unique([promoCodeId, walletAddress]) // Un usuario solo puede usar un código una vez
}

model WeeklyChallenge {
  id              String   @id @default(cuid())
  week            Int      @unique // Week number of the year
  year            Int
  title           String
  description     String
  metric          String   // "likes", "profit", "winRate", "volume", "bestTrade"
  prizeSOL        Float    @default(1.0)
  minCardsRequired Int     @default(100) // Mínimo de cards para activar challenge
  startDate       DateTime
  endDate         DateTime
  winnerAddress   String?
  winnerScore     Float?
  isActive        Boolean  @default(true)

  createdAt       DateTime @default(now())

  @@index([week, year])
  @@index([isActive])
  @@index([endDate])
}

model Referral {
  id                String   @id @default(cuid())
  referrerAddress   String   // Quien refiere
  referredAddress   String   // Quien fue referido
  hasPaid           Boolean  @default(false) // Si el referido pagó
  paidAt            DateTime? // Cuándo pagó
  rewardPaid        Boolean  @default(false) // Si se pagó reward (para futuro)
  rewardAmount      Float?   // Cuánto se pagó (para futuro)

  createdAt         DateTime @default(now())

  @@index([referrerAddress])
  @@index([referredAddress])
  @@index([hasPaid])
  @@unique([referrerAddress, referredAddress]) // No duplicar referidos
}

model RateLimitLog {
  id          String   @id @default(cuid())
  identifier  String   // IP address or wallet address
  endpoint    String?  // Optional: track specific endpoint
  timestamp   DateTime @default(now())

  @@index([identifier, timestamp])
  @@index([timestamp])
}

model ActivityLog {
  id            String   @id @default(cuid())
  walletAddress String
  action        String   // "upgrade", "moonshot", "leaderboard", "referral", "share"
  metadata      Json?    // Additional data (rank, amount, etc)
  createdAt     DateTime @default(now())

  @@index([createdAt])
  @@index([walletAddress])
  @@index([action])
}

// NUEVO: Histórico de scores para gráficos de evolución
model ScoreHistory {
  id            String   @id @default(cuid())
  walletAddress String
  timestamp     DateTime @default(now())
  score         Int      // DegenScore en ese momento
  rank          Int?     // Ranking global en ese momento
  totalTrades   Int
  totalVolume   Float
  profitLoss    Float
  winRate       Float
  badges        Int      // Cantidad de badges

  @@index([walletAddress, timestamp(sort: Desc)])
  @@index([timestamp])
}

// NUEVO: Sistema de seguimiento de wallets
model UserFollows {
  id        String   @id @default(cuid())
  follower  String   // Wallet que sigue
  following String   // Wallet siendo seguida
  createdAt DateTime @default(now())

  @@index([follower, following])
  @@index([following])
  @@unique([follower, following]) // Prevenir duplicados
}

// NUEVO: Preferencias de notificaciones
model NotificationPreferences {
  walletAddress    String   @id
  emailEnabled     Boolean  @default(false)
  telegramEnabled  Boolean  @default(false)
  discordEnabled   Boolean  @default(false)

  // Contactos
  email            String?
  telegramChatId   String?
  discordWebhook   String?

  // Tipos de notificaciones
  followedTrades   Boolean  @default(true)
  milestones       Boolean  @default(true)
  challenges       Boolean  @default(true)

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

// ═══════════════════════════════════════════════════════════════
// ENGAGEMENT & RETENTION FEATURES
// ═══════════════════════════════════════════════════════════════

// Daily Login Streak System
model UserStreak {
  walletAddress    String   @id
  currentStreak    Int      @default(0)  // Días consecutivos
  longestStreak    Int      @default(0)  // Récord personal
  lastLoginDate    DateTime @default(now())
  totalLogins      Int      @default(1)

  // Rewards earned from streaks
  streakPoints     Int      @default(0)  // XP ganados por rachas

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([currentStreak])
  @@index([lastLoginDate])
}

// Daily Challenges System
model DailyChallenge {
  id               String   @id @default(cuid())
  date             DateTime @db.Date  // Día del challenge
  challengeType    String   // "trades", "winRate", "volume", "follows", "share"

  // Challenge parameters
  targetValue      Int      // Meta a alcanzar
  rewardXP         Int      // XP reward
  rewardBadge      String?  // Badge opcional

  title            String   // "Haz 5 trades ganadores"
  description      String   // Descripción del challenge

  // Participations
  completions      DailyChallengeCompletion[]

  createdAt        DateTime @default(now())

  @@unique([date, challengeType])
  @@index([date])
}

model DailyChallengeCompletion {
  id               String   @id @default(cuid())
  challengeId      String
  challenge        DailyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  walletAddress    String

  progress         Int      @default(0)  // Progreso actual
  completed        Boolean  @default(false)
  completedAt      DateTime?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([challengeId, walletAddress])
  @@index([walletAddress])
  @@index([completed])
}

// Trading Competitions (Daily Duels 1v1)
model TradingDuel {
  id               String   @id @default(cuid())
  status           String   @default("open")  // "open", "active", "finished", "cancelled"

  // Participants
  creatorWallet    String
  opponentWallet   String?  // null si aún no hay oponente

  // Competition config
  entryFee         Float    // SOL entry fee (e.g., 0.5)
  duration         Int      @default(86400)  // Duration in seconds (24h)
  startTime        DateTime?
  endTime          DateTime?

  // Virtual trading
  virtualStartBalance Float  @default(10)  // Start balance in virtual SOL

  // Results
  winnerWallet     String?
  creatorROI       Float?   // Return on Investment %
  opponentROI      Float?

  // Transactions
  creatorTxSignature   String?  // Signature del pago de entry
  opponentTxSignature  String?
  payoutTxSignature    String?  // Signature del pago al ganador

  // Virtual trades
  trades           VirtualTrade[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([status])
  @@index([creatorWallet])
  @@index([opponentWallet])
  @@index([createdAt])
}

model VirtualTrade {
  id               String   @id @default(cuid())
  duelId           String
  duel             TradingDuel @relation(fields: [duelId], references: [id], onDelete: Cascade)

  walletAddress    String   // Quién hizo el trade

  // Trade details
  action           String   // "buy" | "sell"
  tokenMint        String   // Token address
  tokenSymbol      String   // Token symbol (e.g., "BONK")

  amountSOL        Float    // Cantidad de SOL virtual usado
  tokenPrice       Float    // Precio del token al momento
  tokenAmount      Float    // Cantidad de tokens comprados/vendidos

  // Balance tracking
  balanceBefore    Float    // Balance antes del trade
  balanceAfter     Float    // Balance después del trade

  timestamp        DateTime @default(now())

  @@index([duelId, walletAddress])
  @@index([timestamp])
}

// User Analytics & Engagement Tracking
model UserAnalytics {
  walletAddress       String   @id

  // Login tracking
  lastLogin           DateTime @default(now())
  loginCount          Int      @default(1)

  // Engagement metrics
  challengesCompleted Int      @default(0)
  duelsPlayed         Int      @default(0)
  duelsWon            Int      @default(0)

  // XP & Leveling
  totalXP             Int      @default(0)
  level               Int      @default(1)

  // Social
  referralsCount      Int      @default(0)
  sharesCount         Int      @default(0)

  // Time spent (in seconds)
  totalTimeSpent      Int      @default(0)

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([totalXP])
  @@index([level])
  @@index([lastLogin])
}

// Achievement System
model Achievement {
  id               String   @id @default(cuid())
  key              String   @unique  // "unicorn_hunter", "ghost_trader", etc.

  name             String   // "Unicorn Hunter"
  description      String   // "Find a 1000x token"
  icon             String   // Emoji or icon
  rarity           String   // "common", "rare", "epic", "legendary"

  // Requirements
  requirementType  String   // "trades", "winRate", "streak", "custom"
  requirementValue Int      // Threshold to unlock

  // Rewards
  rewardXP         Int      @default(0)
  rewardBadge      Boolean  @default(true)

  // Hidden achievements
  isHidden         Boolean  @default(false)

  // Tracking
  unlocks          AchievementUnlock[]

  createdAt        DateTime @default(now())

  @@index([key])
  @@index([rarity])
}

model AchievementUnlock {
  id               String   @id @default(cuid())
  achievementId    String
  achievement      Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  walletAddress    String
  unlockedAt       DateTime @default(now())

  @@unique([achievementId, walletAddress])
  @@index([walletAddress])
  @@index([unlockedAt])
}

// Referral System
model Referral {
  id               String   @id @default(cuid())
  referrerWallet   String   // Quien refiere
  referredWallet   String   // Quien fue referido

  // Tracking
  referredPremium  Boolean  @default(false)  // ¿El referido compró premium?
  rewardPaid       Boolean  @default(false)   // ¿Se pagó reward al referrer?
  rewardAmount     Float?   // Cantidad pagada
  rewardTxSignature String? // Signature del pago

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([referredWallet])  // Cada usuario solo puede ser referido una vez
  @@index([referrerWallet])
  @@index([referredPremium])
}